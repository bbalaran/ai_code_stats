#!/usr/bin/env node

import { writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Ruby LLM models.json URL
const MODELS_URL = "https://raw.githubusercontent.com/crmne/ruby_llm/refs/heads/main/lib/ruby_llm/models.json";

// Provider mappings
const PROVIDER_MAPPINGS = {
	anthropic: "anthropic",
	openai: "openai",
	gemini: "google",
	google: "google",
};

async function fetchModels() {
	console.log("Fetching models from ruby_llm...");

	try {
		const response = await fetch(MODELS_URL);
		if (!response.ok) {
			throw new Error(`HTTP ${response.status}: ${response.statusText}`);
		}

		const models = await response.json();
		console.log(`âœ“ Fetched ${Object.keys(models).length} models`);
		return models;
	} catch (error) {
		console.error("âœ— Failed to fetch models:", error.message);
		process.exit(1);
	}
}

function filterTextModels(models) {
	console.log("Filtering for text input/output models...");

	const textModels = {};
	let filteredCount = 0;

	for (const [modelId, model] of Object.entries(models)) {
		// Check if model supports text input and output
		const modalities = model.modalities || {};
		const hasTextInput = modalities.input?.includes("text") || !modalities.input;
		const hasTextOutput = modalities.output?.includes("text") || !modalities.output;

		// Only include models that support text I/O (may also support other modalities)
		if (hasTextInput && hasTextOutput) {
			textModels[modelId] = model;
			filteredCount++;
		}
	}

	console.log(`âœ“ Filtered to ${filteredCount} text-compatible models`);
	return textModels;
}

function categorizeByProvider(models) {
	console.log("Categorizing models by provider...");

	const categories = {
		anthropic: [],
		openai: [],
		google: [],
		ollama: [], // Will be handled separately as dynamic
	};

	for (const [modelId, model] of Object.entries(models)) {
		const provider = model.provider?.toLowerCase();
		const mappedProvider = PROVIDER_MAPPINGS[provider];

		if (mappedProvider && categories[mappedProvider]) {
			categories[mappedProvider].push({ id: modelId, ...model });
		}
	}

	console.log(`âœ“ Categorized models:`);
	console.log(`  - Anthropic: ${categories.anthropic.length}`);
	console.log(`  - OpenAI: ${categories.openai.length}`);
	console.log(`  - Google: ${categories.google.length}`);

	return categories;
}

function extractCapabilities(model) {
	const capabilities = model.capabilities || [];
	const hasTools = capabilities.includes("function_calling") || capabilities.includes("tools");
	const hasImageInput = model.modalities?.input?.includes("image");

	return {
		supportsTools: hasTools,
		supportsImageInput: hasImageInput,
	};
}

function extractPricing(model) {
	const pricing = model.pricing;
	if (!pricing || !pricing.text_tokens || !pricing.text_tokens.standard) return null;

	const standard = pricing.text_tokens.standard;
	const inputPrice = standard.input_per_million || 0;
	const outputPrice = standard.output_per_million || 0;

	return {
		inputPerMillion: inputPrice,
		outputPerMillion: outputPrice,
	};
}

function generateTypeScript(categories) {
	console.log("Generating TypeScript code...");

	const lines = [
		"// Generated model definitions from ruby_llm",
		"// DO NOT EDIT - This file is auto-generated by scripts/update-models.js",
		"",
		"// Provider-specific model types",
	];

	// Generate type unions for each provider
	const providerTypes = [];
	const modelDataObjects = [];
	const modelToProviderEntries = [];

	for (const [provider, models] of Object.entries(categories)) {
		if (provider === "ollama") continue; // Handle separately

		const typeName =
			provider === "openai" ? "OpenAIModels" : `${provider.charAt(0).toUpperCase() + provider.slice(1)}Models`;
		const modelIds = models.map((m) => `'${m.id}'`).join(" | ");

		if (models.length > 0) {
			lines.push(`export type ${typeName} = ${modelIds}`);
			providerTypes.push(typeName);

			// Generate model data object
			const dataObjectName = `${typeName.replace("Models", "ModelData")}`;
			lines.push("", `export const ${dataObjectName} = {`);

			for (const model of models) {
				const capabilities = extractCapabilities(model);
				const pricing = extractPricing(model);

				lines.push(`  '${model.id}': {`);
				lines.push(`    contextWindow: ${model.context_window || 0},`);
				lines.push(`    maxOutputTokens: ${model.max_output_tokens || 0},`);
				lines.push(`    supportsTools: ${capabilities.supportsTools},`);
				lines.push(`    supportsImageInput: ${capabilities.supportsImageInput},`);

				if (pricing) {
					lines.push(`    pricing: {`);
					lines.push(`      inputPerMillion: ${pricing.inputPerMillion},`);
					lines.push(`      outputPerMillion: ${pricing.outputPerMillion}`);
					lines.push(`    }`);
				} else {
					lines.push(`    pricing: null`);
				}

				lines.push(`  },`);

				// Add to model-to-provider mapping
				modelToProviderEntries.push(`  '${model.id}': '${provider}'`);
			}

			lines.push("} as const");
			modelDataObjects.push(dataObjectName);
		} else {
			lines.push(`export type ${typeName} = never`);
		}
	}

	// Add Ollama type (dynamic string)
	lines.push("", `export type OllamaModels = string`);
	providerTypes.push("OllamaModels");

	// Generate AllModels union
	lines.push("", `export type AllModels = ${providerTypes.join(" | ")}`);

	// Generate ModelToProvider mapping
	lines.push("", "export const ModelToProvider = {");
	lines.push(...modelToProviderEntries.map((entry) => entry + ","));
	lines.push("} as const");

	return lines.join("\n");
}

async function main() {
	try {
		console.log("ðŸš€ Starting model registry update...\n");

		// Fetch and process models
		const allModels = await fetchModels();
		const textModels = filterTextModels(allModels);
		const categories = categorizeByProvider(textModels);

		// Generate TypeScript code
		const tsCode = generateTypeScript(categories);

		// Write to generated/models.ts
		const modelsPath = join(__dirname, "../packages/lemmy/src/generated/models.ts");
		writeFileSync(modelsPath, tsCode, "utf8");

		console.log(`\nâœ“ Generated ${modelsPath}`);
		console.log("ðŸŽ‰ Model registry update complete!");
	} catch (error) {
		console.error("âœ— Update failed:", error.message);
		process.exit(1);
	}
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
	main();
}
